"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var decisionTree = function (BaseError) {
  'use strict';

  BaseError = BaseError && BaseError.hasOwnProperty('default') ? BaseError['default'] : BaseError;

  function findItemByKey() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        if (item.key === key) {
          return item;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  var index =
  /*#__PURE__*/
  function () {
    function index() {
      var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [tree];
      var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _classCallCheck2.default)(this, index);
      this.path = path;
      this.state = state;
      this.noChildren = "No children found to move to";
      this.noLead = "Can't determine which child to move to";
      this.noParent = "No parent node found to move to";
    }

    (0, _createClass2.default)(index, [{
      key: "set",
      value: function set(key, value) {
        if ((0, _typeof2.default)(key) === 'object' && value === undefined) {
          this.state = key;
        } else {
          this.state[key] = value;
        }

        return this;
      }
    }, {
      key: "current",
      value: function current() {
        return this.path[this.path.length - 1];
      }
    }, {
      key: "goToNode",
      value: function goToNode(node) {
        return node ? this.path.push(node) && node : node;
      }
    }, {
      key: "getNodeFromLeadsTo",
      value: function getNodeFromLeadsTo(currentNode, _ref) {
        var leadsTo = _ref.leadsTo;
        var key = typeof leadsTo === 'function' ? leadsTo(this) : leadsTo;
        return findItemByKey(currentNode.children, key);
      }
    }, {
      key: "next",
      value: function next() {
        var currentNode = this.current(); // Get the selected option key from state or extract it from an array if
        // multiple options can be selected.

        var selectedOptionKey = this.state[currentNode.key];

        if (Array.isArray(selectedOptionKey) && selectedOptionKey.length === 1) {
          selectedOptionKey = selectedOptionKey[0];
        } // Find the selected option object by it's key.


        var selectedOption = findItemByKey(currentNode.options, selectedOptionKey); // Move to the next node.

        if (currentNode.children.length < 1) {
          // No children to move to!
          throw new BaseError(this.noChildren, currentNode);
        } else if (currentNode.children.length === 1) {
          // Move to the only child.
          return this.goToNode(currentNode.children[0]);
        } else if (selectedOption && selectedOption.leadsTo) {
          // Move to what the single selected option tells us to move to.
          return this.goToNode(this.getNodeFromLeadsTo(currentNode, selectedOption));
        } else if (currentNode.leadsTo) {
          // Move to what the currentNode tells us to move to (maybe there are
          // multiple options selected).
          return this.goToNode(this.getNodeFromLeadsTo(currentNode, currentNode));
        } // Throw an error if the next node to move to can't be determined.


        throw new BaseError(this.noLead, selectedOptionKey, selectedOption);
      }
    }, {
      key: "prev",
      value: function prev() {
        var parentNode = this.path[this.path.length - 2];

        if (parentNode) {
          return this.path.pop();
        }

        throw new BaseError(this.noParent);
      }
    }, {
      key: "pathKeys",
      value: function pathKeys() {
        return this.path.map(function (_ref2) {
          var key = _ref2.key;
          return key;
        });
      }
    }]);
    return index;
  }();

  return index;
}(BaseError);